The first step in the OptiFuzz pipeline is code generation. 
The code generation module is written in OCaml and works by generating abstract syntax trees according to the grammar in Figure \ref{fig:grammar}.

\begin{figure}[H]
  \centering
  \begin{align*}
    e \in Expr ::= & x \mid y &\text{(input variables)}\\
    & n \in \{0, 1\}^{64} &\text{(64-bit integer literals)}\\
    & -e \mid e + e \mid e - e \mid e \times e &\text{(arithmetic operators)}\\
    & \texttt{true} \mid \texttt{false} &\text{(boolean literals)}\\
    & !e &\text{(logical operators)}\\
    & e < e \mid e \leq e \mid e > e \mid e \geq e \mid e = e \mid e \neq e &\text{(comparison operators)}\\
    & e \texttt{\&} e \mid e \texttt{|} e \mid \text{\~{}} e \mid e \text{\^{}} e \mid e \ll e \mid e \gg e &\text{(bitwise operators)}
  \end{align*}
  \caption{The grammar that defines the ASTs generated by the code generation module in the OptiFuzz pipeline.}
  \label{fig:grammar}
\end{figure}

The grammar defines all programs with 2 variables and non-branching arithmetic, logical and comparison operations in C \cite{c-standard}, excluding division (\texttt{/}) and modulus (\texttt{\%}).
The reason for excluding division and modulus is that they may cause division-by-zero errors.
Generated programs are forced to include both input variables, $x$ and $y$.
$x$ and $y$ are the inputs to the program, and we require both to be present since programs with 0 or 1 input variables are trivially constant-time.
An example of a program generated by the code generation module is shown in Figure \ref{fig:code-gen-example}.

\begin{figure}[H]
  \begin{lstlisting}[style=defstyle,language=C]
#define false 0
#define true 1
int program(int x, int y) { return !(y * (43 * (x != true))); } \end{lstlisting}
  \caption{Example of a program generated by the code generation module.}
  \label{fig:code-gen-example}
\end{figure}

The code generation module works by generating a random distribution that selects different symbols in the grammar with a certain probability.
This ensures that not all generated programs will be uniformly random.
For example, if a generated distribution heavily favors the left-shift operator, then the generated programs will contain a lot of left-shift operations.
This is useful for detecting whether certain types of programs are more likely to be constant-time than others.

The code generation module generates programs with integer literals in different ranges. 
Booleans represent the first range.
Defining Booleans as integers is a common practice in C \cite{c-standard}.
Integers from this range are included since the constants 0 and 1 are interesting in many operations.
The second range we consider is $[0, 64]$ as numbers in this range are lower than the size of 64-bit integers.
Hence numbers in this range are interesting in bit-shifting operations.
The third range is the range of signed 64-bit integers.
Generally, we have included these smaller ranges of integers since they are interesting and it is very unlikely that a uniformly random 64-bit integer would be in these ranges.

The grammar in Figure \ref{fig:grammar} generates programs with undefined behavior.
For example, bit-shifting with a negative number, or a number larger than the size of the type, is undefined behavior in C \cite{c-standard}.
We chose to include undefined behavior in the grammar since it is a source of timing vulnerabilities \cite{what-you-c}, and it is common in real-life code \cite{undefined-behavior-c}.
The grammar also does not distinguish operations on Booleans and integers and hence generates untypical C programs.
For example, the program in Figure \ref{fig:code-gen-example} features multiplication between a Boolean and an integer.
We chose to include this in the grammar since it is a used trick to avoid branching in constant-time code \cite{what-you-c}.

\subsubsection{Limitations}
The biggest limitation of this approach is that the generated programs are not representative of real-life code since they use such a limited subset of the C language.
However, as argued above the simple constant-time programs are representative of how real code might look, and thus gives a useful insight into the issue of timing vulnerabilities introduced by the compiler.