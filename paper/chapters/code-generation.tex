The first step in the OptiFuzz pipeline is code generation. 
The code generation module is written in OCaml and works by generating abstract syntax trees according to the grammar in Figure \ref{fig:grammar}.

\begin{figure}[H]
  \centering
  \begin{align*}
    e \in Expr ::= & x \mid y &\text{(input variables)}\\
    & n \in \{0, 1\}^{64} &\text{(64-bit integer literals)}\\
    & -e \mid e + e \mid e - e \mid e \times e &\text{(arithmetic operators)}\\
    & \texttt{true} \mid \texttt{false} &\text{(boolean literals)}\\
    & !e &\text{(logical operators)}\\
    & e < e \mid e \leq e \mid e > e \mid e \geq e \mid e = e \mid e \neq e &\text{(comparison operators)}\\
    & e \texttt{\&} e \mid e \texttt{|} e \mid \text{\~{}} e \mid e \text{\^{}} e \mid e \ll e \mid e \gg e &\text{(bitwise operators)}
  \end{align*}
  \caption{The grammar that defines the ASTs generated by the code generation module in the OptiFuzz pipeline.}
  \label{fig:grammar}
\end{figure}

The grammar defines all programs with 2 variables and non-branching arithmetic, logical and comparison operations in C \cite{c-standard}, excluding division (\texttt{/}) and modulus (\texttt{\%}).
The reason for excluding division and modulus is that they may cause division-by-zero errors.
Generated programs are forced to include both input variables, $x$ and $y$.
$x$ and $y$ are the inputs to the program, and we require both to be present since programs with 0 or 1 input variables are trivially constant-time.
Furthermore, Booleans are defined as the integer literals 0 and 1 just like in the C standard library \texttt{stdbool} \cite{c-standard}.
An example of a program generated by the code generation module is shown in Figure \ref{fig:code-gen-example}.

\begin{figure}[H]
  \begin{lstlisting}[style=defstyle,language=C]
#define false 0
#define true 1
int program(int x, int y) { return !(y * (43 * (x != true))); } \end{lstlisting}
  \caption{Example of a program generated by the code generation module.}
  \label{fig:code-gen-example}
\end{figure}

The code generation module works by generating a random distribution that selects different symbols in the grammar with a certain probability.
This ensures that not all generated programs will be uniformly random.
For example, if a generated distribution heavily favors the left-shift operator, then the generated programs will contain a lot of left-shift operations.
This is useful for detecting whether certain types of programs are more likely to be constant-time than others.

The grammar in Figure \ref{fig:grammar} generates programs that are not typical 

\todo{Argue why not a more realistic grammar was chosen}
\todo{Find examples of weird real life programs}
\subsubsection{Limitations}
