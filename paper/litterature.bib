@inproceedings{developer-survey-timing-attacks,
  author={Jancar, Jan and Fourné, Marcel and Braga, Daniel De Almeida and Sabt, Mohamed and Schwabe, Peter and Barthe, Gilles and Fouque, Pierre-Alain and Acar, Yasemin},
  booktitle={2022 IEEE Symposium on Security and Privacy (SP)}, 
  title={{“They're not that hard to mitigate”: What Cryptographic Library Developers Think About Timing Attacks}}, 
  year={2022},
  volume={},
  number={},
  pages={632-649},
  doi={10.1109/SP46214.2022.9833713}
}

@inproceedings{optimizations-linked-to-timing-attacks,
  author={D'Silva, Vijay and Payer, Mathias and Song, Dawn},
  booktitle={2015 IEEE Security and Privacy Workshops}, 
  title={{The Correctness-Security Gap in Compiler Optimization}}, 
  year={2015},
  volume={},
  number={},
  pages={73-87},
  doi={10.1109/SPW.2015.33}}

@inproceedings{what-you-c,
  author={Simon, Laurent and Chisnall, David and Anderson, Ross},
  booktitle={2018 IEEE European Symposium on Security and Privacy (EuroS\&P)}, 
  title={{What You Get is What You C: Controlling Side Effects in Mainstream C Compilers}}, 
  year={2018},
  volume={},
  number={},
  pages={1-15},
  doi={10.1109/EuroSP.2018.00009}
}

@techreport{c-standard,
  type         = {Standard},
  institution  = {International Organization for Standardization},
  title        = {{Programming languages - C}},
  key          = {ISO/IEC 9899:2018},
  year         = {2018},
  month        = {jun}
}

@article{verified-constant-time-c-comiler,
  author = {Barthe, Gilles and Blazy, Sandrine and Gr\'{e}goire, Benjamin and Hutin, R\'{e}mi and Laporte, Vincent and Pichardie, David and Trieu, Alix},
  title = {{Formal Verification of a Constant-Time Preserving C Compiler}},
  year = {2019},
  issue_date = {January 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {4},
  number = {POPL},
  url = {https://doi.org/10.1145/3371075},
  doi = {10.1145/3371075},
  abstract = {Timing side-channels are arguably one of the main sources of vulnerabilities in cryptographic implementations. One effective mitigation against timing side-channels is to write programs that do not perform secret-dependent branches and memory accesses. This mitigation, known as "cryptographic constant-time", is adopted by several popular cryptographic libraries. This paper focuses on compilation of cryptographic constant-time programs, and more specifically on the following question: is the code generated by a realistic compiler for a constant-time source program itself provably constant-time? Surprisingly, we answer the question positively for a mildly modified version of the CompCert compiler, a formally verified and moderately optimizing compiler for C. Concretely, we modify the CompCert compiler to eliminate sources of potential leakage. Then, we instrument the operational semantics of CompCert intermediate languages so as to be able to capture cryptographic constant-time. Finally, we prove that the modified CompCert compiler preserves constant-time. Our mechanization maximizes reuse of the CompCert correctness proof, through the use of new proof techniques for proving preservation of constant-time. These techniques achieve complementary trade-offs between generality and tractability of proof effort, and are of independent interest.},
  journal = {Proc. ACM Program. Lang.},
  month = {dec},
  articleno = {7},
  numpages = {30},
  keywords = {CompCert compiler, verified compilation, timing side-channels}
}

@inproceedings{dudect,
  author={Reparaz, Oscar and Balasch, Josep and Verbauwhede, Ingrid},
  booktitle={Design, Automation \& Test in Europe Conference \& Exhibition (DATE), 2017}, 
  title={Dude, is my code constant time?}, 
  year={2017},
  volume={},
  number={},
  pages={1697-1702},
  doi={10.23919/DATE.2017.7927267}
}

@inproceedings{undefined-behavior-c,
  author = {Wang, Xi and Chen, Haogang and Cheung, Alvin and Jia, Zhihao and Zeldovich, Nickolai and Kaashoek, M. Frans},
  title = {{Undefined Behavior: What Happened to My Code?}},
  year = {2012},
  isbn = {9781450316699},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2349896.2349905},
  doi = {10.1145/2349896.2349905},
  abstract = {System programming languages such as C grant compiler writers freedom to generate efficient code for a specific instruction set by defining certain language constructs as undefined behavior. Unfortunately, the rules for what is undefined behavior are subtle and programmers make mistakes that sometimes lead to security vulnerabilities. This position paper argues that the research community should help address the problems that arise from undefined behavior, and not dismiss them as esoteric C implementation issues. We show that these errors do happen in real-world systems, that the issues are tricky, and that current practices to address the issues are insufficient.},
  booktitle = {Proceedings of the Asia-Pacific Workshop on Systems},
  articleno = {9},
  numpages = {7},
  location = {Seoul, Republic of Korea},
  series = {APSYS '12}
}

@inproceedings{fact,
  author={Cauligi, Sunjay and Soeller, Gary and Brown, Fraser and Johannesmeyer, Brian and Huang, Yunlu and Jhala, Ranjit and Stefan, Deian},
  booktitle={2017 IEEE Cybersecurity Development (SecDev)}, 
  title={{FaCT: A Flexible, Constant-Time Programming Language}}, 
  year={2017},
  volume={},
  number={},
  pages={69-76},
  doi={10.1109/SecDev.2017.24}
}

@inproceedings{1996-timing-attacks,
  author="Kocher, Paul C.",
  editor="Koblitz, Neal",
  title="Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems",
  booktitle="Advances in Cryptology --- CRYPTO '96",
  year="1996",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="104--113",
  abstract="By carefully measuring the amount of time required to perform private key operations, attackers may be able to find fixed Diffie-Hellman exponents, factor RSA keys, and break other cryptosystems. Against a vulnerable system, the attack is computationally inexpensive and often requires only known ciphertext. Actual systems are potentially at risk, including cryptographic tokens, network-based cryptosystems, and other applications where attackers can make reasonably accurate timing measurements. Techniques for preventing the attack for RSA and Diffie-Hellman are presented. Some cryptosystems will need to be revised to protect against the attack, and new protocols and algorithms may need to incorporate measures to prevent timing attacks.",
  isbn="978-3-540-68697-2"
}

@manual{intel-reference,
  title={Intel® 64 and IA-32 Architectures Software Developer's Manual},
  volumes={1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4},
  author={Intel},
  year={2023},
  url={https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html},
  note={a. (Vol.3A Ch.9.3 pp.17-18), b. (Vol.3B Ch.18.17.1 p.43)}
}

@inproceedings{cmov-is-constant-time,
  author={Coppens, Bart and Verbauwhede, Ingrid and De Bosschere, Koen and De Sutter, Bjorn},
  booktitle={2009 30th IEEE Symposium on Security and Privacy}, 
  title={Practical Mitigations for Timing-Based Side-Channel Attacks on Modern x86 Processors}, 
  year={2009},
  volume={},
  number={},
  pages={45-60},
  doi={10.1109/SP.2009.19}
}

@manual{cmov-from-1995,
  title={Pentium Pro Family Developer's Manual},
  volumes={2},
  author={Intel},
  year={1995},
  url={https://stuff.mit.edu/afs/sipb/contrib/doc/specs/ic/cpu/x86/pentium-pro/vol2.pdf}
}

@manual{llvm-optimizing-away-cmov,
  title={LLVM 17.0.0 documentation: X86CmovConversion.cpp File Reference},
  author={LLVM},
  year={2023},
  url={https://llvm.org/doxygen/X86CmovConversion_8cpp.html}
}

@manual{gcc-manual,
  title={GCC 12.2 Manual: Options That Control Optimization},
  author={GNU},
  year={2022},
  url={https://gcc.gnu.org/onlinedocs/gcc-12.2.0/gcc/Optimize-Options.html#Optimize-Options}
}

@techreport{intel-benchmark-code-execution,
     author = {Gabriele Paoloni},
     title = {{How to Benchmark Code Execution Times on Intel® IA-32 and IA-64 Instruction Set Architectures}},
     institution = {Intel},
     year = {2010},
     month = {10},
     url={https://www.intel.de/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf}
}

@misc{robust-benchmarking,
  doi = {10.48550/ARXIV.1608.04295},
  url = {https://arxiv.org/abs/1608.04295},
  author = {Chen, Jiahao and Revels, Jarrett},
  keywords = {Performance (cs.PF), FOS: Computer and information sciences, FOS: Computer and information sciences, B.8.1; D.2.5, 68N30},
  title = {Robust benchmarking in noisy environments},
  publisher = {arXiv},
  year = {2016},
  copyright = {arXiv.org perpetual, non-exclusive license}
}

@article{Coron_2004,
	doi = {10.1145/1015047.1015050},
	url = {https://doi.org/10.1145%2F1015047.1015050},
	year = 2004,
	month = {aug},
	publisher = {Association for Computing Machinery ({ACM})},
	volume = {3},
	number = {3},
	pages = {492--508},
	author = {Jean-Sebastien Coron and David Naccache and Paul Kocher},
	title = {Statistics and secret leakage},
	journal = {{ACM} Transactions on Embedded Computing Systems}
}

@inproceedings{Abel19a,
  title = {uops.info: Characterizing Latency, Throughput, and Port Usage of Instructions on Intel Microarchitectures},
  acmid = {3304062},
  address = {New York, NY, USA},
  author = {Abel, Andreas and Reineke, Jan},
  booktitle = {ASPLOS},
  doi = {10.1145/3297858.3304062},
  isbn = {978-1-4503-6240-5},
  location = {Providence, RI, USA},
  numpages = {14},
  pages = {673--686},
  publisher = {ACM},
  series = {ASPLOS '19},
  year = {2019},
  url = {http://doi.acm.org/10.1145/3297858.3304062}
}

@article{WELCH1947,
  doi = {10.1093/biomet/34.1-2.28},
  url = {https://doi.org/10.1093/biomet/34.1-2.28},
  year = {1947},
  publisher = {Oxford University Press ({OUP})},
  volume = {34},
  number = {1-2},
  pages = {28--35},
  author = {B. L. Welch},
  title = {{THE} {GENERALIZATION} {OF} `{STUDENT}{\textquotesingle}S' {PROBLEM} {WHEN} {SEVERAL} {DIFFERENT} {POPULATION} {VARLANCES} {ARE} {INVOLVED}},
  journal = {Biometrika}
}

@misc{cryptoeprint:2015/536,
      author = {François Durvaux and François-Xavier Standaert},
      title = {From Improved Leakage Detection to the Detection of Points of Interests in Leakage Traces},
      howpublished = {Cryptology ePrint Archive, Paper 2015/536},
      year = {2015},
      note = {\url{https://eprint.iacr.org/2015/536}},
      url = {https://eprint.iacr.org/2015/536}
}

@inproceedings{Goodwill2011ATM,
  title={A testing methodology for side channel resistance},
  author={Gilbert Goodwill and Benjamin Jun and Joshua Jaffe and Pankaj Rohatgi},
  year={2011}
}

@misc{openssl,
  title={OpenSSL GitHub Repository},
  author={OpenSSL},
  year={2023},
  url={https://github.com/openssl/openssl}
}

@manual{intel-optimization-reference,
  title={Intel® 64 and IA-32 Architectures Optimization Reference Manual},
  author={Intel},
  year={2023},
  url={https://cdrdv2.intel.com/v1/dl/getContent/671488?explicitVersion=true},
  section={3.4.1}
}

@misc{llvm-issues-blog-post,
  title={LLVM provides no side-channel resistance},
  author={Amber Sprenkels},
  year={2019},
  url={https://electricdusk.com/cmov-conversion.html}
}

@inproceedings{verifying-constant-time-llvm,
author = {Almeida, Jos\'{e} Bacelar and Barbosa, Manuel and Barthe, Gilles and Dupressoir, Fran\c{c}ois and Emmi, Michael},
title = {Verifying Constant-Time Implementations},
year = {2016},
isbn = {9781931971324},
publisher = {USENIX Association},
address = {USA},
abstract = {The constant-time programming discipline is an effective countermeasure against timing attacks, which can lead to complete breaks of otherwise secure systems. However, adhering to constant-time programming is hard on its own, and extremely hard under additional efficiency and legacy constraints. This makes automated verification of constant-time code an essential component for building secure software.We propose a novel approach for verifying constant-time security of real-world code. Our approach is able to validate implementations that locally and intentionally violate the constant-time policy, when such violations are benign and leak no more information than the public outputs of the computation. Such implementations, which are used in cryptographic libraries to obtain important speedups or to comply with legacy APIs, would be declared insecure by all prior solutions.We implement our approach in a publicly available, cross-platform, and fully automated prototype, ct-verif, that leverages the SMACK and Boogie tools and verifies optimized LLVM implementations. We present verification results obtained over a wide range of constant-time components from the NaCl, OpenSSL, FourQ and other off-the-shelf libraries. The diversity and scale of our examples, as well as the fact that we deal with top-level APIs rather than being limited to low-level leaf functions, distinguishes ct-verif from prior tools.Our approach is based on a simple reduction of constant-time security of a program P to safety of a product program Q that simulates two executions of P. We formalize and verify the reduction for a core high-level language using the Coq proof assistant.},
booktitle = {Proceedings of the 25th USENIX Conference on Security Symposium},
pages = {53–70},
numpages = {18},
location = {Austin, TX, USA},
series = {SEC'16}
}