@inproceedings{developer-survey-timing-attacks,
  author={Jancar, Jan and Fourné, Marcel and Braga, Daniel De Almeida and Sabt, Mohamed and Schwabe, Peter and Barthe, Gilles and Fouque, Pierre-Alain and Acar, Yasemin},
  booktitle={2022 IEEE Symposium on Security and Privacy (SP)}, 
  title={{“They're not that hard to mitigate”: What Cryptographic Library Developers Think About Timing Attacks}}, 
  year={2022},
  volume={},
  number={},
  pages={632-649},
  doi={10.1109/SP46214.2022.9833713}
}

@inproceedings{optimizations-linked-to-timing-attacks,
  author={D'Silva, Vijay and Payer, Mathias and Song, Dawn},
  booktitle={2015 IEEE Security and Privacy Workshops}, 
  title={{The Correctness-Security Gap in Compiler Optimization}}, 
  year={2015},
  volume={},
  number={},
  pages={73-87},
  doi={10.1109/SPW.2015.33}}

@inproceedings{what-you-c,
  author={Simon, Laurent and Chisnall, David and Anderson, Ross},
  booktitle={2018 IEEE European Symposium on Security and Privacy (EuroS\&P)}, 
  title={{What You Get is What You C: Controlling Side Effects in Mainstream C Compilers}}, 
  year={2018},
  volume={},
  number={},
  pages={1-15},
  doi={10.1109/EuroSP.2018.00009}
}

@book{c-standard,
  author       = {ISO},
  title        = {{Programming languages - C} ISO/IEC 9899:2018},
  year         = {2018}
}

@article{verified-constant-time-c-comiler,
  author = {Barthe, Gilles and Blazy, Sandrine and Gr\'{e}goire, Benjamin and Hutin, R\'{e}mi and Laporte, Vincent and Pichardie, David and Trieu, Alix},
  title = {{Formal Verification of a Constant-Time Preserving C Compiler}},
  year = {2019},
  issue_date = {January 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {4},
  number = {POPL},
  url = {https://doi.org/10.1145/3371075},
  doi = {10.1145/3371075},
  abstract = {Timing side-channels are arguably one of the main sources of vulnerabilities in cryptographic implementations. One effective mitigation against timing side-channels is to write programs that do not perform secret-dependent branches and memory accesses. This mitigation, known as "cryptographic constant-time", is adopted by several popular cryptographic libraries. This paper focuses on compilation of cryptographic constant-time programs, and more specifically on the following question: is the code generated by a realistic compiler for a constant-time source program itself provably constant-time? Surprisingly, we answer the question positively for a mildly modified version of the CompCert compiler, a formally verified and moderately optimizing compiler for C. Concretely, we modify the CompCert compiler to eliminate sources of potential leakage. Then, we instrument the operational semantics of CompCert intermediate languages so as to be able to capture cryptographic constant-time. Finally, we prove that the modified CompCert compiler preserves constant-time. Our mechanization maximizes reuse of the CompCert correctness proof, through the use of new proof techniques for proving preservation of constant-time. These techniques achieve complementary trade-offs between generality and tractability of proof effort, and are of independent interest.},
  journal = {Proc. ACM Program. Lang.},
  month = {dec},
  articleno = {7},
  numpages = {30},
  keywords = {CompCert compiler, verified compilation, timing side-channels}
}

@inproceedings{dudect,
  author={Reparaz, Oscar and Balasch, Josep and Verbauwhede, Ingrid},
  booktitle={Design, Automation \& Test in Europe Conference \& Exhibition (DATE), 2017}, 
  title={Dude, is my code constant time?}, 
  year={2017},
  volume={},
  number={},
  pages={1697-1702},
  doi={10.23919/DATE.2017.7927267}}

@inproceedings{undefined-behavior-c,
  author = {Wang, Xi and Chen, Haogang and Cheung, Alvin and Jia, Zhihao and Zeldovich, Nickolai and Kaashoek, M. Frans},
  title = {{Undefined Behavior: What Happened to My Code?}},
  year = {2012},
  isbn = {9781450316699},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2349896.2349905},
  doi = {10.1145/2349896.2349905},
  abstract = {System programming languages such as C grant compiler writers freedom to generate efficient code for a specific instruction set by defining certain language constructs as undefined behavior. Unfortunately, the rules for what is undefined behavior are subtle and programmers make mistakes that sometimes lead to security vulnerabilities. This position paper argues that the research community should help address the problems that arise from undefined behavior, and not dismiss them as esoteric C implementation issues. We show that these errors do happen in real-world systems, that the issues are tricky, and that current practices to address the issues are insufficient.},
  booktitle = {Proceedings of the Asia-Pacific Workshop on Systems},
  articleno = {9},
  numpages = {7},
  location = {Seoul, Republic of Korea},
  series = {APSYS '12}
}