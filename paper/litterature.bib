@inproceedings{developer-survey-timing-attacks,
  author={Jancar, Jan and Fourné, Marcel and Braga, Daniel De Almeida and Sabt, Mohamed and Schwabe, Peter and Barthe, Gilles and Fouque, Pierre-Alain and Acar, Yasemin},
  booktitle={2022 IEEE Symposium on Security and Privacy (SP)}, 
  title={{“They're not that hard to mitigate”: What Cryptographic Library Developers Think About Timing Attacks}}, 
  year={2022},
  volume={},
  number={},
  pages={632-649},
  doi={10.1109/SP46214.2022.9833713}
}

@inproceedings{optimizations-linked-to-timing-attacks,
  author={D'Silva, Vijay and Payer, Mathias and Song, Dawn},
  booktitle={2015 IEEE Security and Privacy Workshops}, 
  title={{The Correctness-Security Gap in Compiler Optimization}}, 
  year={2015},
  volume={},
  number={},
  pages={73-87},
  doi={10.1109/SPW.2015.33}}

@inproceedings{what-you-c,
  author={Simon, Laurent and Chisnall, David and Anderson, Ross},
  booktitle={2018 IEEE European Symposium on Security and Privacy (EuroS\&P)}, 
  title={{What You Get is What You C: Controlling Side Effects in Mainstream C Compilers}}, 
  year={2018},
  volume={},
  number={},
  pages={1-15},
  doi={10.1109/EuroSP.2018.00009}
}

@book{c-standard,
  author       = {ISO},
  title        = {{Programming languages - C} ISO/IEC 9899:2018},
  year         = {2018}
}

@article{verified-constant-time-c-comiler,
  author = {Barthe, Gilles and Blazy, Sandrine and Gr\'{e}goire, Benjamin and Hutin, R\'{e}mi and Laporte, Vincent and Pichardie, David and Trieu, Alix},
  title = {{Formal Verification of a Constant-Time Preserving C Compiler}},
  year = {2019},
  issue_date = {January 2020},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {4},
  number = {POPL},
  url = {https://doi.org/10.1145/3371075},
  doi = {10.1145/3371075},
  abstract = {Timing side-channels are arguably one of the main sources of vulnerabilities in cryptographic implementations. One effective mitigation against timing side-channels is to write programs that do not perform secret-dependent branches and memory accesses. This mitigation, known as "cryptographic constant-time", is adopted by several popular cryptographic libraries. This paper focuses on compilation of cryptographic constant-time programs, and more specifically on the following question: is the code generated by a realistic compiler for a constant-time source program itself provably constant-time? Surprisingly, we answer the question positively for a mildly modified version of the CompCert compiler, a formally verified and moderately optimizing compiler for C. Concretely, we modify the CompCert compiler to eliminate sources of potential leakage. Then, we instrument the operational semantics of CompCert intermediate languages so as to be able to capture cryptographic constant-time. Finally, we prove that the modified CompCert compiler preserves constant-time. Our mechanization maximizes reuse of the CompCert correctness proof, through the use of new proof techniques for proving preservation of constant-time. These techniques achieve complementary trade-offs between generality and tractability of proof effort, and are of independent interest.},
  journal = {Proc. ACM Program. Lang.},
  month = {dec},
  articleno = {7},
  numpages = {30},
  keywords = {CompCert compiler, verified compilation, timing side-channels}
}

@inproceedings{dudect,
  author={Reparaz, Oscar and Balasch, Josep and Verbauwhede, Ingrid},
  booktitle={Design, Automation \& Test in Europe Conference \& Exhibition (DATE), 2017}, 
  title={Dude, is my code constant time?}, 
  year={2017},
  volume={},
  number={},
  pages={1697-1702},
  doi={10.23919/DATE.2017.7927267}
}

@inproceedings{undefined-behavior-c,
  author = {Wang, Xi and Chen, Haogang and Cheung, Alvin and Jia, Zhihao and Zeldovich, Nickolai and Kaashoek, M. Frans},
  title = {{Undefined Behavior: What Happened to My Code?}},
  year = {2012},
  isbn = {9781450316699},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2349896.2349905},
  doi = {10.1145/2349896.2349905},
  abstract = {System programming languages such as C grant compiler writers freedom to generate efficient code for a specific instruction set by defining certain language constructs as undefined behavior. Unfortunately, the rules for what is undefined behavior are subtle and programmers make mistakes that sometimes lead to security vulnerabilities. This position paper argues that the research community should help address the problems that arise from undefined behavior, and not dismiss them as esoteric C implementation issues. We show that these errors do happen in real-world systems, that the issues are tricky, and that current practices to address the issues are insufficient.},
  booktitle = {Proceedings of the Asia-Pacific Workshop on Systems},
  articleno = {9},
  numpages = {7},
  location = {Seoul, Republic of Korea},
  series = {APSYS '12}
}

@inproceedings{fact,
  author={Cauligi, Sunjay and Soeller, Gary and Brown, Fraser and Johannesmeyer, Brian and Huang, Yunlu and Jhala, Ranjit and Stefan, Deian},
  booktitle={2017 IEEE Cybersecurity Development (SecDev)}, 
  title={{FaCT: A Flexible, Constant-Time Programming Language}}, 
  year={2017},
  volume={},
  number={},
  pages={69-76},
  doi={10.1109/SecDev.2017.24}
}

@inproceedings{1996-timing-attacks,
  author="Kocher, Paul C.",
  editor="Koblitz, Neal",
  title="Timing Attacks on Implementations of Diffie-Hellman, RSA, DSS, and Other Systems",
  booktitle="Advances in Cryptology --- CRYPTO '96",
  year="1996",
  publisher="Springer Berlin Heidelberg",
  address="Berlin, Heidelberg",
  pages="104--113",
  abstract="By carefully measuring the amount of time required to perform private key operations, attackers may be able to find fixed Diffie-Hellman exponents, factor RSA keys, and break other cryptosystems. Against a vulnerable system, the attack is computationally inexpensive and often requires only known ciphertext. Actual systems are potentially at risk, including cryptographic tokens, network-based cryptosystems, and other applications where attackers can make reasonably accurate timing measurements. Techniques for preventing the attack for RSA and Diffie-Hellman are presented. Some cryptosystems will need to be revised to protect against the attack, and new protocols and algorithms may need to incorporate measures to prevent timing attacks.",
  isbn="978-3-540-68697-2"
}

@manual{intel-reference,
  title={Intel 64 and IA-32 Architectures Software Developer's Manual},
  volumes={1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4},
  author={Intel},
  year={2023},
  url={https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html}
}

@inproceedings{cmov-is-constant-time,
  author={Coppens, Bart and Verbauwhede, Ingrid and De Bosschere, Koen and De Sutter, Bjorn},
  booktitle={2009 30th IEEE Symposium on Security and Privacy}, 
  title={Practical Mitigations for Timing-Based Side-Channel Attacks on Modern x86 Processors}, 
  year={2009},
  volume={},
  number={},
  pages={45-60},
  doi={10.1109/SP.2009.19}
}

@techreport{intel-benchmark-code-execution,
     author = {Gabriele Paoloni},
     title = {{How to Benchmark Code Execution Times on Intel ® IA-32 and IA-64 Instruction Set Architectures}},
     institution = {Intel Corporation},
     year = {2010},
     month = {10},
     url={https://www.intel.de/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf}
}
